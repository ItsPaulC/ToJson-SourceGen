using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace ToJson.SourceGen
{
    [Generator]
    public class ToJsonGenerator : IIncrementalGenerator
    {
        private const string AttributeSourceCode = @"
namespace ToJson
{
    [System.AttributeUsage(System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    public sealed class ToJsonAttribute : System.Attribute
    {
    }
}";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Register the attribute source
            context.RegisterPostInitializationOutput(ctx =>
                ctx.AddSource("ToJsonAttribute.g.cs", SourceText.From(AttributeSourceCode, Encoding.UTF8)));

            // Find all classes with the ToJson attribute
            IncrementalValuesProvider<ClassDeclarationSyntax> classDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                    transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
                .Where(static m => m is not null)!;

            // Combine with compilation
            IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndClasses
                = context.CompilationProvider.Combine(classDeclarations.Collect());

            // Generate the ToJson methods
            context.RegisterSourceOutput(compilationAndClasses,
                static (spc, source) => Execute(source.Item1, source.Item2, spc));
        }

        private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
        {
            return node is ClassDeclarationSyntax classDeclaration
                && classDeclaration.AttributeLists.Count > 0;
        }

        private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
        {
            ClassDeclarationSyntax classDeclaration = (ClassDeclarationSyntax)context.Node;

            foreach (AttributeListSyntax attributeList in classDeclaration.AttributeLists)
            {
                foreach (AttributeSyntax attribute in attributeList.Attributes)
                {
                    IMethodSymbol? attributeSymbol = context.SemanticModel.GetSymbolInfo(attribute).Symbol as IMethodSymbol;
                    if (attributeSymbol == null)
                    {
                        continue;
                    }

                    INamedTypeSymbol attributeContainingTypeSymbol = attributeSymbol.ContainingType;
                    string fullName = attributeContainingTypeSymbol.ToDisplayString();

                    if (fullName == "ToJson.ToJsonAttribute")
                    {
                        return classDeclaration;
                    }
                }
            }

            return null;
        }

        private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes, SourceProductionContext context)
        {
            if (classes.IsDefaultOrEmpty)
            {
                return;
            }

            IEnumerable<ClassDeclarationSyntax> distinctClasses = classes.Distinct();

            foreach (ClassDeclarationSyntax classDeclaration in distinctClasses)
            {
                SemanticModel semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
                INamedTypeSymbol? classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

                if (classSymbol == null)
                {
                    continue;
                }

                string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
                string className = classSymbol.Name;
                string source = GenerateToJsonMethod(classSymbol, namespaceName, className);

                context.AddSource($"{className}.ToJson.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        }

        private static string GenerateToJsonMethod(INamedTypeSymbol classSymbol, string namespaceName, string className)
        {
            StringBuilder sb = new StringBuilder();

            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine();
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
            sb.AppendLine($"    partial class {className}");
            sb.AppendLine("    {");
            sb.AppendLine("        public string ToJson()");
            sb.AppendLine("        {");
            sb.AppendLine("            var sb = new System.Text.StringBuilder();");
            sb.AppendLine("            sb.Append(\"{\");");

            IEnumerable<ISymbol> members = classSymbol.GetMembers()
                .Where(m => m.Kind == SymbolKind.Property || m.Kind == SymbolKind.Field)
                .Where(m => !m.IsStatic && m.DeclaredAccessibility == Accessibility.Public);

            bool first = true;
            foreach (ISymbol member in members)
            {
                string memberName = member.Name;
                ITypeSymbol? memberType = member switch
                {
                    IPropertySymbol prop => prop.Type,
                    IFieldSymbol field => field.Type,
                    _ => null
                };

                if (memberType == null)
                {
                    continue;
                }

                if (!first)
                {
                    sb.AppendLine("            sb.Append(\",\");");
                }
                first = false;

                sb.AppendLine($"            sb.Append(\"\\\"{memberName}\\\":\");");

                string valueExpression = GenerateValueExpression(memberType, memberName);
                sb.AppendLine($"            sb.Append({valueExpression});");
            }

            sb.AppendLine("            sb.Append(\"}\");");
            sb.AppendLine("            return sb.ToString();");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private static string GenerateValueExpression(ITypeSymbol typeSymbol, string memberName)
        {
            // Handle nullable value types
            if (typeSymbol is INamedTypeSymbol { IsValueType: true, NullableAnnotation: NullableAnnotation.Annotated } namedTypeSymbol)
            {
                ITypeSymbol underlyingType = namedTypeSymbol.TypeArguments.FirstOrDefault() ?? typeSymbol;
                string underlyingExpression = GenerateValueExpression(underlyingType, $"{memberName}.Value");
                return $"({memberName}.HasValue ? {underlyingExpression} : \"null\")";
            }

            // Handle null for reference types
            bool isNullable = typeSymbol.IsReferenceType || typeSymbol.NullableAnnotation == NullableAnnotation.Annotated;
            string nullCheck = isNullable ? $"({memberName} == null ? \"null\" : " : "";
            string nullCheckClose = isNullable ? ")" : "";

            switch (typeSymbol.SpecialType)
            {
                case SpecialType.System_String:
                    return $"{nullCheck}\"\\\"\" + System.Text.Json.JsonEncodedText.Encode({memberName}).ToString() + \"\\\"\"{nullCheckClose}";

                case SpecialType.System_Int32:
                case SpecialType.System_Int64:
                case SpecialType.System_Int16:
                case SpecialType.System_Byte:
                case SpecialType.System_UInt32:
                case SpecialType.System_UInt64:
                case SpecialType.System_UInt16:
                case SpecialType.System_SByte:
                case SpecialType.System_Single:
                case SpecialType.System_Double:
                case SpecialType.System_Decimal:
                    return $"{memberName}.ToString()";

                case SpecialType.System_Boolean:
                    return $"({memberName} ? \"true\" : \"false\")";

                default:
                    // For complex types, check if they have the ToJson attribute or ToJson method
                    if (typeSymbol is INamedTypeSymbol namedType)
                    {
                        // Check if the type has the [ToJson] attribute
                        bool hasToJsonAttribute = namedType.GetAttributes()
                            .Any(attr => attr.AttributeClass?.ToDisplayString() == "ToJson.ToJsonAttribute");

                        // Check if the type has a ToJson method (might not be visible during generation)
                        IMethodSymbol? toJsonMethod = namedType.GetMembers("ToJson")
                            .OfType<IMethodSymbol>()
                            .FirstOrDefault(m => m.Parameters.Length == 0 && m.ReturnType.SpecialType == SpecialType.System_String);

                        if (hasToJsonAttribute || toJsonMethod != null)
                        {
                            return $"{nullCheck}{memberName}.ToJson(){nullCheckClose}";
                        }
                    }

                    // Fallback: use ToString and quote it
                    return $"{nullCheck}\"\\\"\" + {memberName}.ToString() + \"\\\"\"{nullCheckClose}";
            }
        }
    }
}
