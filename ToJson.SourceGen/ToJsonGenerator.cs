using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace ToJson.SourceGen
{
    [Generator]
    public class ToJsonGenerator : IIncrementalGenerator
    {
        private const string AttributeSourceCode = @"
namespace ToJson
{
    [System.AttributeUsage(System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    public sealed class ToJsonAttribute : System.Attribute
    {
    }
}";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Register the attribute source
            context.RegisterPostInitializationOutput(ctx =>
                ctx.AddSource("ToJsonAttribute.g.cs", SourceText.From(AttributeSourceCode, Encoding.UTF8)));

            // Find all classes with the ToJson attribute
            IncrementalValuesProvider<ClassDeclarationSyntax> classDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                    transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
                .Where(static m => m is not null)!;

            // Combine with compilation
            IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndClasses
                = context.CompilationProvider.Combine(classDeclarations.Collect());

            // Generate the ToJson methods
            context.RegisterSourceOutput(compilationAndClasses,
                static (spc, source) => Execute(source.Item1, source.Item2, spc));
        }

        private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
        {
            return node is ClassDeclarationSyntax classDeclaration
                && classDeclaration.AttributeLists.Count > 0;
        }

        private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
        {
            ClassDeclarationSyntax classDeclaration = (ClassDeclarationSyntax)context.Node;

            foreach (AttributeListSyntax attributeList in classDeclaration.AttributeLists)
            {
                foreach (AttributeSyntax attribute in attributeList.Attributes)
                {
                    IMethodSymbol? attributeSymbol = context.SemanticModel.GetSymbolInfo(attribute).Symbol as IMethodSymbol;
                    if (attributeSymbol == null)
                    {
                        continue;
                    }

                    INamedTypeSymbol attributeContainingTypeSymbol = attributeSymbol.ContainingType;
                    string fullName = attributeContainingTypeSymbol.ToDisplayString();

                    if (fullName == "ToJson.ToJsonAttribute")
                    {
                        return classDeclaration;
                    }
                }
            }

            return null;
        }

        private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes, SourceProductionContext context)
        {
            if (classes.IsDefaultOrEmpty)
            {
                return;
            }

            IEnumerable<ClassDeclarationSyntax> distinctClasses = classes.Distinct();

            foreach (ClassDeclarationSyntax classDeclaration in distinctClasses)
            {
                SemanticModel semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
                INamedTypeSymbol? classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

                if (classSymbol == null)
                {
                    continue;
                }

                string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
                string className = classSymbol.Name;
                string source = GenerateToJsonMethod(classSymbol, namespaceName, className);

                context.AddSource($"{className}.ToJson.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        }

        private static string GenerateToJsonMethod(INamedTypeSymbol classSymbol, string namespaceName, string className)
        {
            StringBuilder sb = new StringBuilder();
            List<(string memberName, ITypeSymbol elementType)> collectionMembers = new List<(string, ITypeSymbol)>();

            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine();
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
            sb.AppendLine($"    partial class {className}");
            sb.AppendLine("    {");

            // Generate overload without parameters (defaults to non-indented)
            sb.AppendLine("        public string ToJson()");
            sb.AppendLine("        {");
            sb.AppendLine("            return ToJson(false);");
            sb.AppendLine("        }");
            sb.AppendLine();

            // Generate main method with indentation parameter
            sb.AppendLine("        public string ToJson(bool indented)");
            sb.AppendLine("        {");
            sb.AppendLine("            return ToJsonCore(indented, 0);");
            sb.AppendLine("        }");
            sb.AppendLine();

            // Generate core implementation
            sb.AppendLine("        public string ToJsonCore(bool indented, int depth)");
            sb.AppendLine("        {");
            sb.AppendLine("            var sb = new System.Text.StringBuilder();");
            sb.AppendLine("            string indent = indented ? new string(' ', depth * 2) : \"\";");
            sb.AppendLine("            string indent2 = indented ? new string(' ', (depth + 1) * 2) : \"\";");
            sb.AppendLine("            string newline = indented ? \"\\r\\n\" : \"\";");
            sb.AppendLine("            sb.Append(\"{\");");
            sb.AppendLine("            sb.Append(newline);");

            IEnumerable<ISymbol> members = classSymbol.GetMembers()
                .Where(m => m.Kind == SymbolKind.Property || m.Kind == SymbolKind.Field)
                .Where(m => !m.IsStatic && m.DeclaredAccessibility == Accessibility.Public);

            bool first = true;
            foreach (ISymbol member in members)
            {
                string memberName = member.Name;
                ITypeSymbol? memberType = member switch
                {
                    IPropertySymbol prop => prop.Type,
                    IFieldSymbol field => field.Type,
                    _ => null
                };

                if (memberType == null)
                {
                    continue;
                }

                // Track collection members for helper method generation
                if (memberType is IArrayTypeSymbol arrayType)
                {
                    collectionMembers.Add((memberName, arrayType.ElementType));
                }
                else if (TryGetEnumerableElementType(memberType, out ITypeSymbol? elementType))
                {
                    collectionMembers.Add((memberName, elementType!));
                }

                if (!first)
                {
                    sb.AppendLine("            sb.Append(\",\");");
                    sb.AppendLine("            sb.Append(newline);");
                }
                first = false;

                sb.AppendLine("            sb.Append(indent2);");
                sb.AppendLine($"            sb.Append(\"\\\"{memberName}\\\":\");");
                sb.AppendLine("            if (indented) sb.Append(\" \");");

                string valueExpression = GenerateValueExpression(memberType, memberName, "indented", "depth");
                sb.AppendLine($"            sb.Append({valueExpression});");
            }

            sb.AppendLine("            sb.Append(newline);");
            sb.AppendLine("            sb.Append(indent);");
            sb.AppendLine("            sb.Append(\"}\");");
            sb.AppendLine("            return sb.ToString();");
            sb.AppendLine("        }");

            // Generate helper methods for collections
            foreach (var (memberName, elementType) in collectionMembers)
            {
                sb.AppendLine();
                sb.Append(GenerateCollectionHelperMethod(memberName, elementType, className));
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private static string GenerateValueExpression(ITypeSymbol typeSymbol, string memberName, string indentedVar = "false", string depthVar = "0")
        {
            // Handle nullable value types
            if (typeSymbol is INamedTypeSymbol { IsValueType: true, NullableAnnotation: NullableAnnotation.Annotated } namedTypeSymbol)
            {
                ITypeSymbol underlyingType = namedTypeSymbol.TypeArguments.FirstOrDefault() ?? typeSymbol;
                string underlyingExpression = GenerateValueExpression(underlyingType, $"{memberName}.Value", indentedVar, depthVar);
                return $"({memberName}.HasValue ? {underlyingExpression} : \"null\")";
            }

            // Handle arrays
            if (typeSymbol is IArrayTypeSymbol arrayType)
            {
                return GenerateArrayExpression(arrayType, memberName, indentedVar, depthVar);
            }

            // Handle collections (IEnumerable<T>)
            if (TryGetEnumerableElementType(typeSymbol, out ITypeSymbol? elementType))
            {
                return GenerateCollectionExpression(elementType!, memberName, indentedVar, depthVar);
            }

            // Handle null for reference types
            bool isNullable = typeSymbol.IsReferenceType || typeSymbol.NullableAnnotation == NullableAnnotation.Annotated;
            string nullCheck = isNullable ? $"({memberName} == null ? \"null\" : " : "";
            string nullCheckClose = isNullable ? ")" : "";

            switch (typeSymbol.SpecialType)
            {
                case SpecialType.System_String:
                    return $"{nullCheck}\"\\\"\" + System.Text.Json.JsonEncodedText.Encode({memberName}).ToString() + \"\\\"\"{nullCheckClose}";

                case SpecialType.System_Int32:
                case SpecialType.System_Int64:
                case SpecialType.System_Int16:
                case SpecialType.System_Byte:
                case SpecialType.System_UInt32:
                case SpecialType.System_UInt64:
                case SpecialType.System_UInt16:
                case SpecialType.System_SByte:
                case SpecialType.System_Single:
                case SpecialType.System_Double:
                case SpecialType.System_Decimal:
                    return $"{memberName}.ToString()";

                case SpecialType.System_Boolean:
                    return $"({memberName} ? \"true\" : \"false\")";

                default:
                    // For complex types, check if they have the ToJson attribute or ToJson method
                    if (typeSymbol is INamedTypeSymbol namedType)
                    {
                        // Check if the type has the [ToJson] attribute
                        bool hasToJsonAttribute = namedType.GetAttributes()
                            .Any(attr => attr.AttributeClass?.ToDisplayString() == "ToJson.ToJsonAttribute");

                        // Check if the type has a ToJson method (might not be visible during generation)
                        IMethodSymbol? toJsonMethod = namedType.GetMembers("ToJson")
                            .OfType<IMethodSymbol>()
                            .FirstOrDefault(m => m.Parameters.Length == 0 && m.ReturnType.SpecialType == SpecialType.System_String);

                        if (hasToJsonAttribute || toJsonMethod != null)
                        {
                            return $"{nullCheck}{memberName}.ToJsonCore({indentedVar}, {depthVar} + 1){nullCheckClose}";
                        }
                    }

                    // Fallback: use ToString and quote it
                    return $"{nullCheck}\"\\\"\" + {memberName}.ToString() + \"\\\"\"{nullCheckClose}";
            }
        }

        private static string GenerateArrayExpression(IArrayTypeSymbol arrayType, string memberName, string indentedVar, string depthVar)
        {
            ITypeSymbol elementType = arrayType.ElementType;
            return GenerateCollectionExpression(elementType, memberName, indentedVar, depthVar);
        }

        private static string GenerateCollectionExpression(ITypeSymbol elementType, string memberName, string indentedVar, string depthVar)
        {
            // Generate a unique variable name for the loop
            string itemVar = $"item_{memberName}";
            string itemExpression = GenerateValueExpression(elementType, itemVar, indentedVar, depthVar);

            // Generate method call for formatting collection
            return $"FormatCollection_{memberName}({memberName}, {indentedVar}, {depthVar})";
        }

        private static string GenerateCollectionHelperMethod(string memberName, ITypeSymbol elementType, string className)
        {
            string itemVar = $"item_{memberName}";
            string itemExpression = GenerateValueExpression(elementType, itemVar, "indented", "depth + 1");

            StringBuilder sb = new StringBuilder();
            sb.AppendLine($"        private static string FormatCollection_{memberName}(System.Collections.Generic.IEnumerable<{elementType.ToDisplayString()}> collection, bool indented, int depth)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (collection == null) return \"null\";");
            sb.AppendLine("            var sb = new System.Text.StringBuilder();");
            sb.AppendLine("            string itemIndent = indented ? new string(' ', (depth + 2) * 2) : \"\";");
            sb.AppendLine("            string closeIndent = indented ? new string(' ', (depth + 1) * 2) : \"\";");
            sb.AppendLine("            string newline = indented ? \"\\r\\n\" : \"\";");
            sb.AppendLine("            sb.Append(\"[\");");
            sb.AppendLine("            bool first = true;");
            sb.AppendLine($"            foreach (var {itemVar} in collection)");
            sb.AppendLine("            {");
            sb.AppendLine("                if (!first)");
            sb.AppendLine("                {");
            sb.AppendLine("                    sb.Append(\",\");");
            sb.AppendLine("                }");
            sb.AppendLine("                first = false;");
            sb.AppendLine("                sb.Append(newline);");
            sb.AppendLine("                sb.Append(itemIndent);");
            sb.AppendLine($"                sb.Append({itemExpression});");
            sb.AppendLine("            }");
            sb.AppendLine("            if (indented && !first)");
            sb.AppendLine("            {");
            sb.AppendLine("                sb.Append(newline);");
            sb.AppendLine("                sb.Append(closeIndent);");
            sb.AppendLine("            }");
            sb.AppendLine("            sb.Append(\"]\");");
            sb.AppendLine("            return sb.ToString();");
            sb.AppendLine("        }");
            return sb.ToString();
        }

        private static bool TryGetEnumerableElementType(ITypeSymbol typeSymbol, out ITypeSymbol? elementType)
        {
            elementType = null;

            // Skip string (it's IEnumerable<char> but we don't want to treat it as a collection)
            if (typeSymbol.SpecialType == SpecialType.System_String)
            {
                return false;
            }

            // Check if it's a named type that implements IEnumerable<T>
            if (typeSymbol is INamedTypeSymbol namedType)
            {
                // Check the type itself
                if (namedType.OriginalDefinition.SpecialType == SpecialType.System_Collections_Generic_IEnumerable_T)
                {
                    elementType = namedType.TypeArguments.FirstOrDefault();
                    return elementType != null;
                }

                // Check all interfaces
                foreach (INamedTypeSymbol interfaceType in namedType.AllInterfaces)
                {
                    if (interfaceType.OriginalDefinition.SpecialType == SpecialType.System_Collections_Generic_IEnumerable_T)
                    {
                        elementType = interfaceType.TypeArguments.FirstOrDefault();
                        return elementType != null;
                    }
                }
            }

            return false;
        }
    }
}
